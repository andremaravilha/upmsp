package upmsp.algorithm.neighborhood;

import upmsp.model.*;
import upmsp.model.solution.*;

import java.util.*;

/**
 * This class represents a Shift Move (as in the paper). A neighbor in the Shift
 * Move is generated by re-scheduling one job from the machine with the largest
 * total execution time (or a random machine) to another position in the
 * machine. The parameter "useMakespanMachine" determines whether the machine
 * with the largest total execution time is always used.
 *
 * @author Tulio Toffolo
 */
public class Shift extends Move {

    private Machine machine;
    private int pos1, pos2, job;
    private boolean useMakespanMachine;

    /**
     * Instantiates a new Shift Move.
     *
     * @param problem            problem.
     * @param random             random number generator.
     * @param priority           the priority of this neighborhood.
     * @param useMakespanMachine true if the makespan machine should be always
     *                           considered or false otherwise.
     */
    public Shift(Problem problem, Random random, int priority, boolean useMakespanMachine) {
        super(problem, random, "Shift" + (useMakespanMachine ? "(mk)" : ""), priority);
        this.useMakespanMachine = useMakespanMachine;
    }

    public void accept() {
        super.accept();
    }

    public int doMove(Solution solution) {
        super.doMove(solution);

        // selecting machines to involve in operation
        if (useMakespanMachine && solution.makespanMachine.getNJobs() > 1) {
            machine = solution.makespanMachine;
        }
        else {
            int m;
            do {
                m = random.nextInt(solution.machines.length);
            }
            while (solution.machines[m].getNJobs() <= 1);
            machine = solution.machines[m];
        }

        // selecting jobs to perform operation
        do {
            pos1 = random.nextInt(machine.getNJobs());
            pos2 = random.nextInt(machine.getNJobs());
        }
        while (pos1 == pos2);
        job = machine.jobs[pos1];

        // moving jobs
        machine.delJob(pos1);
        machine.addJob(job, pos2);

        solution.updateCost();
        return deltaCost = solution.getCost() - initialCost;
    }

    public boolean hasMove(Solution solution) {
        return !useMakespanMachine || solution.makespanMachine.getNJobs() > 1;
    }

    public void reject() {
        super.reject();

        machine.delJob(pos2);
        machine.addJob(job, pos1);
        currentSolution.updateCost();
    }
}
